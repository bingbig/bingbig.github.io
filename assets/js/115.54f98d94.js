(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{415:function(t,e,r){"use strict";r.r(e);var _=r(0),n=Object(_.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),r("ul",[r("li",[r("router-link",{attrs:{to:"./preface.html"}},[t._v("目录")])],1),t._v(" "),r("li",[t._v("15.1 "),r("router-link",{attrs:{to:"./15.1.html"}},[t._v("php流的表象之下")])],1),t._v(" "),r("li",[t._v("15.3 "),r("router-link",{attrs:{to:"./15.3.html"}},[t._v("实现一个包装器")])],1)])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"包装器操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#包装器操作","aria-hidden":"true"}},[this._v("#")]),this._v(" 包装器操作")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("p",[t._v("除了url_stat()函数, 包装器操作中在const char *label元素之前的每个操作都可以用于激活的流实例上. 每个函数的意义如下:\n"),r("table",[r("tr",[r("td",[t._v("stream_opener()")]),t._v(" "),r("td",[t._v("\n实例化一个流实例. 当某个用户空间的fopen()函数被调用时, 这个函数将被调用. 这个函数返回的php_stream实例是fopen()函数返回的文件资源句柄的内部表示. 集成函数比如file(), file_get_contents(), file_put_contents(), readfile()等等, 在请求包装资源时, 都使用这个包装器ops.\n")])]),t._v(" "),r("tr",[r("td",[t._v("stream_closer()")]),t._v(" "),r("td",[t._v("\n当一个流实例结束其生命周期时这个函数被调用. stream_opener()时分配的所有资源都应该在这个函数中被释放.\n")])]),t._v(" "),r("tr",[r("td",[t._v("stream_stat()")]),t._v(" "),r("td",[t._v("\n类似于用户空间的fstat()函数, 这个函数应该填充ssb结构体(实际上只包含一个struct statbuf sb结构体成员),\n")])]),t._v(" "),r("tr",[r("td",[t._v("dir_opener()")]),t._v(" "),r("td",[t._v("\n和stream_opener()行为一致, 不过它是调用opendir()一族的用户空间函数时被调用的. 目录流使用的底层流实现和文件流遵循相同的规则;不过目录流只需要返回包含在打开的目录中找到的文件名的记录, 它的大小为struct dirent这个结构体的大小.\n")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"静态包装器操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态包装器操作","aria-hidden":"true"}},[this._v("#")]),this._v(" 静态包装器操作")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("p",[t._v("包装器操作函数中的其他函数是在URI路径上执行原子操作, 具体取决于包装器协议. 在php4.3的php_stream_wrapper_ops结构体中只有url_stat()和unlink(); 其他的方式是到php 5.0后才定义的, 编码时应该适时的使用#ifdef块说明.\n"),r("table",[r("tr",[r("td",[t._v("url_stat()")]),t._v(" "),r("td",[t._v("\nstat()族函数使用, 返回文件元数据, 比如访问授权, 大小, 类型; 以及访问, 修改,创建时间. 尽管这个函数是在php 4.3引入流包装层时出现在php_stream_wrapper_ops结构体中的, 但直到php 5.0才被用户空间的stat()函数使用.\n")])]),t._v(" "),r("tr",[r("td",[t._v("unlink()")]),t._v(" "),r("td",[t._v("\n和posix文件系统的同名函数语义相同, 它执行文件删除. 如果对于当前的包装器删除没有意义, 比如内建的http://包装器, 这个函数应该被定义为NULL, 以便内核去引发适当的错误消息.\n")])]),t._v(" "),r("tr",[r("td",[t._v("rename()")]),t._v(" "),r("td",[t._v("\n当用户空间的rename()函数的参数$from和$to参数指向的是相同的底层包装器实现, php则将这个重命名请求分发到包装器的rename函数.\n")])]),t._v(" "),r("tr",[r("td",[t._v("mkdir() & rmdir()")]),t._v(" "),r("td",[t._v("\n这两个函数直接映射到对应的用户空间函数.\n")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"links"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#links","aria-hidden":"true"}},[this._v("#")]),this._v(" links")])}],!1,null,null,null);n.options.__file="15.2.md";e.default=n.exports}}]);