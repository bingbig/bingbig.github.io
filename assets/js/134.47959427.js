(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{386:function(t,e,r){"use strict";r.r(e);var l=r(0),s=Object(l.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),r("p",[t._v("##目录")]),t._v(" "),r("ul",[r("li",[r("router-link",{attrs:{to:"./18.1.html"}},[t._v("1. ext_skel")])],1),t._v(" "),r("li",[r("router-link",{attrs:{to:"./18.2.html"}},[t._v("2. PECL_Gen")])],1),t._v(" "),r("li",[r("router-link",{attrs:{to:"./18.3.html"}},[t._v("3. 小结")])],1)]),t._v(" "),r("p",[t._v("毫无疑问你已经注意到，每个php扩展都包含一些非常公共的并且非常单调的结构和文件。当开始一个新扩展开发的时候，如果这些公共的结构已经存在, 我们只用考虑填充功 能代码是很有意义的. 为此, 在php中包含了一个简单但是很有用的shell脚本。")]),t._v(" "),t._m(1),t._v(" "),r("ul",[r("li",[r("router-link",{attrs:{to:"./preface.html"}},[t._v("目录")])],1),t._v(" "),r("li",[t._v("17.3 "),r("router-link",{attrs:{to:"./17.3.html"}},[t._v("小结")])],1),t._v(" "),r("li",[t._v("18.1 "),r("router-link",{attrs:{to:"./18.1.html"}},[t._v("ext_skel")])],1)])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"_18-扩展生成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-扩展生成","aria-hidden":"true"}},[this._v("#")]),this._v(" 18 扩展生成")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"links"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#links","aria-hidden":"true"}},[this._v("#")]),this._v(" links")])}],!1,null,null,null);s.options.__file="18.md";e.default=s.exports}}]);