(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{468:function(t,_,a){"use strict";a.r(_);var e=a(0),v=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存","aria-hidden":"true"}},[t._v("#")]),t._v(" 内存")]),t._v(" "),a("h2",{attrs:{id:"_1-内存分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存分区","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. 内存分区")]),t._v(" "),a("h3",{attrs:{id:"_1-1-固定分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-固定分区","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.1 固定分区")]),t._v(" "),a("p",[t._v("管理用户内存的最简单的方案，就是对其分区，形成若干固定边界的区域。可分为大小相等的分区和大小不等的分区。")]),t._v(" "),a("p",[a("code",[t._v("内部碎片（internal fragmentation）")]),t._v("： 分区内部存在空间浪费。")]),t._v(" "),a("h3",{attrs:{id:"_1-2-动态分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-动态分区","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.2 动态分区")]),t._v(" "),a("p",[t._v("分区的长度和数量是可变的，进程装入内存时，系统会给它分配一块与其所需容量完全相同的内存空间。")]),t._v(" "),a("p",[a("code",[t._v("外部碎片（external fragmentation）")]),t._v("：指在所有分区外的存储空间变成了越来越多的碎片。克服的一种办法是"),a("code",[t._v("压缩（compaction）")]),t._v("：操作系统不时的移动进程，使得进程占用的内存空间连续，并使得空闲的内存连成一片。")]),t._v(" "),a("p",[a("code",[t._v("置换算法")]),t._v("：在使用动态分区的是多道程序设计系统中，有时会出现内存中的所有进程都处于阻塞态的情况，即使进行了压缩仍没有足够的空间。为避免由于等待一个活动进程解除阻塞态引起的处理器是时间浪费，操作系统将一个阻塞态进程换出内存，给新进程或除于就绪－挂起态的进程让出空间。")]),t._v(" "),a("h3",{attrs:{id:"_1-3-伙伴系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-伙伴系统","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.3 伙伴系统")]),t._v(" "),a("p",[t._v("每次都将内存空间分为大小相等的两块，若两个内存块是大小相等的伙伴，则至少分配出去一个，否则它们将合并成为一个更大的块。")]),t._v(" "),a("h3",{attrs:{id:"_1-4-分页"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-分页","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.4  分页")]),t._v(" "),a("p",[t._v("将内存划分成大小固定、相等的块，且块的相对比较小，每个进程也被分成同样的小块，那么进程中称为"),a("code",[t._v("页")]),t._v("的块可以分配到内存中称为"),a("code",[t._v("页框（frame）")]),t._v("的可用块。")]),t._v(" "),a("p",[t._v("操作系统需要为每个进程维护一个"),a("code",[t._v("页表")]),t._v("，页表给出了该进程的每页所对应的页框的位置。在程序中，每个逻辑地址包括一个页号和在该页中的偏移量。")]),t._v(" "),a("h3",{attrs:{id:"_1-5-分段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-分段","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.5 分段")]),t._v(" "),a("p",[t._v("把程序和其相关数据划分为几个"),a("code",[t._v("段（segment）")]),t._v("的技术称为"),a("code",[t._v("分段技术")]),t._v("。和分页技术一样，采用分段技术时的逻辑地址也由两部分组成，段号和偏移量。")]),t._v(" "),a("h2",{attrs:{id:"_2-虚拟内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-虚拟内存","aria-hidden":"true"}},[t._v("#")]),t._v(" 2. 虚拟内存")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("术语")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("虚拟内存")]),t._v(" "),a("td",[t._v("在存储分配机制中，尽管备用内存时主存的一部分，但它也可以被寻址。程序引用内存使用的地址与内存系统用于识别物理存储站点的地址是不同的，程序生成的地址会被自动转换成机器地址。虚拟存储的大小受计算机系统寻址机制和可用的备用内存量的限制，而不收主存储位置实际数量的限制。")])]),t._v(" "),a("tr",[a("td",[t._v("虚拟地址")]),t._v(" "),a("td",[t._v("在虚拟内存中分配给某一个位置的地址，它使得该位置可被访问，就好像是主内的一部分那样")])]),t._v(" "),a("tr",[a("td",[t._v("地址空间")]),t._v(" "),a("td",[t._v("用于某进程的内存地址范围")])]),t._v(" "),a("tr",[a("td",[t._v("实地址")]),t._v(" "),a("td",[t._v("内存中存储位置的地址")])])])])])}],!1,null,null,null);v.options.__file="memory.md";_.default=v.exports}}]);