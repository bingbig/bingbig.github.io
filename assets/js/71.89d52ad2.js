(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{243:function(t,_,v){"use strict";v.r(_);var a=v(0),e=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"并发性：互斥与同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并发性：互斥与同步","aria-hidden":"true"}},[t._v("#")]),t._v(" 并发性：互斥与同步")]),t._v(" "),v("p",[t._v("并发是所有问题的基础，也是操作系统设计的基础。并发包括很多设计问题，其中有进程通信、资源和竞争、多个进程活动的同步以及给进程分配处理器时间等。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("感知程度")]),t._v(" "),v("th",[t._v("关系")]),t._v(" "),v("th",[t._v("一个进程对其它进程的影响")]),t._v(" "),v("th",[t._v("潜在的控制问题")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("进程之间不知道对方的存在")]),t._v(" "),v("td",[t._v("竞争")]),t._v(" "),v("td",[t._v("一个进程的结果与另外一个无关;进程的执行时间可能会受到影响")]),t._v(" "),v("td",[t._v("互斥、死锁、饥饿")])]),t._v(" "),v("tr",[v("td",[t._v("进程间接知道对方的存在")]),t._v(" "),v("td",[t._v("通过共享合作")]),t._v(" "),v("td",[t._v("一个进程的结果可能取决于从另一个进程获得的信息；进程的执行时间可能会受到影响")]),t._v(" "),v("td",[t._v("互斥、死锁、饥饿、数据一致性")])]),t._v(" "),v("tr",[v("td",[t._v("进程直接知道对方的存在")]),t._v(" "),v("td",[t._v("通过通信合作")]),t._v(" "),v("td",[t._v("一个进程的结果可能取决于从另一个进程获得的信息；进程的执行时间可能会受到影响")]),t._v(" "),v("td",[t._v("死锁（可消耗资源）、饥饿")])])])]),t._v(" "),v("h2",{attrs:{id:"_1-互斥的要求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-互斥的要求","aria-hidden":"true"}},[t._v("#")]),t._v(" 1. 互斥的要求")]),t._v(" "),v("ol",[v("li",[t._v("必须强制实施互斥：在与相同资源或共享对象的临界区有关的所有进程中，一次只允许一个进程进入临界区")]),t._v(" "),v("li",[t._v("一个在非临界区停止的进程不能干涉其他进程")]),t._v(" "),v("li",[t._v("绝不允许出现需要访问临界区的进程被无限延迟的情况，即不会出现死锁或者饥饿")]),t._v(" "),v("li",[t._v("对相关进程的执行速度和处理器的数量没有任何要求和限制")]),t._v(" "),v("li",[t._v("一个进程驻留在临界区中的时间必须是有限的")])]),t._v(" "),v("p",[t._v("互斥的硬件支持：")]),t._v(" "),v("ol",[v("li",[t._v("终端禁用")]),t._v(" "),v("li",[t._v("专用机器指令")])]),t._v(" "),v("h2",{attrs:{id:"_2-信号量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-信号量","aria-hidden":"true"}},[t._v("#")]),t._v(" 2. 信号量")]),t._v(" "),v("p",[t._v("一般常用的并发机制如下表：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("机制")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("信号量")]),t._v(" "),v("td",[t._v("用于进程间传递信号的一个整数值。在信号量上只能进行三种原子操作（初始化、递减和增加）。递减操作是用于阻塞一个进程，递增操作是用于解除对一个进程的阻塞。信号量也称为计数信号量或一般信号量")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("二元信号量")]),t._v(" "),v("td",[t._v("只取值0或1的信号量")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("互斥量")]),t._v(" "),v("td",[t._v("类似于二元信号量。关键区别在于为其加锁（设定值为0）的进程和为其解锁（设定值为1）的进程必须为同一个进程")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("条件变量")]),t._v(" "),v("td",[t._v("一种数据类型，用于阻塞进程或线程，直到特定的条件为真")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("管程")]),t._v(" "),v("td",[t._v("一种编程语言结构，它在一个抽象数据类型中封装了变量、访问过程和初始化代码。管程的变量只能由自身的访问过程访问，每次只能有一个进程在其中执行。访问过程即临界区。管程可以有一个进程等待队列")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("事件标志")]),t._v(" "),v("td",[t._v("用作同步机制的一个内存字。应用程序代码可为标志中的每个位关联不同的事件。通过测试相关的一个或多个位，线程可以等待一个事件或多个事件。在全部所需要的位都被设定或至少有一个位被设定之前，线程会一直被阻塞")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("消息")]),t._v(" "),v("td",[t._v("两个进程交换信息的一种方法，也可用于同步")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("自旋锁")]),t._v(" "),v("td",[t._v("一种互斥锁，进程在一个无条件循环中执行，等待锁变量的值可用")])])])]),t._v(" "),v("h3",{attrs:{id:"_2-1-消费者和生产者问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-消费者和生产者问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.1 消费者和生产者问题")]),t._v(" "),v("ol",[v("li",[t._v("有一个或多个生产者生产某种类型的数据，并放置在缓冲区中；")]),t._v(" "),v("li",[t._v("有一个消费者从缓冲区中取数据，每次取一项；")]),t._v(" "),v("li",[t._v("系统保证避免对缓冲区的重复操作，即在任何时候只有一个主体（生产者或消费者）可访问缓冲区；")]),t._v(" "),v("li",[t._v("当缓冲区已满时，生产者不会向其中添加数据；")]),t._v(" "),v("li",[t._v("当缓冲区为空时，消费者不会从中移走数据。")])]),t._v(" "),v("h2",{attrs:{id:"_3-管程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-管程","aria-hidden":"true"}},[t._v("#")]),t._v(" 3. 管程")]),t._v(" "),v("p",[t._v("管程由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：")]),t._v(" "),v("ol",[v("li",[t._v("局部数据变量只能被管程的过程访问，任何外部过程都不能访问")]),t._v(" "),v("li",[t._v("一个进程通过调用管程的一个过程进入管程")]),t._v(" "),v("li",[t._v("在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用")])]),t._v(" "),v("h2",{attrs:{id:"_4-消息传递"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-消息传递","aria-hidden":"true"}},[t._v("#")]),t._v(" 4. 消息传递")]),t._v(" "),v("p",[t._v("进程交互时，必须满足两个基本要求：同步和通信。为实施互斥，进程需要同步；为实现合作，进程需要交换信息。")]),t._v(" "),v("p",[t._v("两个进程间的通信隐含着某种同步的信息：只有当一个进程发送消息后，接受者才能接收到信息。")]),t._v(" "),v("p",[t._v("消息传递的实际功能通过一对原语实现：")]),t._v(" "),v("div",{staticClass:"language-bash line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[t._v("send"),v("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("destination, message"),v("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nreceive"),v("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("source, message"),v("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("p",[v("strong",[t._v("寻址")]),t._v("\tsend原语中哪里一个进程接受消息很重要。直接寻址是原语中包括目标进程的识别号。间接寻址时，消息不发送到特定的进程，而是发送到一个共享的数据结构，该结构由临时保存信息的队列组成，这些队列通畅被称为"),v("code",[t._v("邮箱")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"_5-读者／写者问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-读者／写者问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 5. 读者／写者问题")]),t._v(" "),v("p",[t._v("存在一个多进程共享的数据区，改数据区可以是一个文本或一块内存空间，甚至可以是一组寄存器；有些进程（reader）只能读取这个数据区中的数据，有些进程（writer）只能往数据区中写数据，此外，还必须满足以下条件：")]),t._v(" "),v("ol",[v("li",[t._v("任意数量的读进程可以同时读取这个文件；")]),t._v(" "),v("li",[t._v("一次只有一个写进程可以写文件；")]),t._v(" "),v("li",[t._v("若一个进程正在写文件，则禁止其他任何进程读取文件")])]),t._v(" "),v("h3",{attrs:{id:"_5-1-读者优先"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-读者优先","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.1 读者优先")]),t._v(" "),v("p",[t._v("第一个试图读的读进程需要等待写进程不再访问共享数据区，当至少一个读进程在读时，随后的读进程无序等待，可以直接进入。")]),t._v(" "),v("h3",{attrs:{id:"_5-2-写者优先"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-写者优先","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.2 写者优先")]),t._v(" "),v("p",[t._v("在一个写进程声明想写时，不运行新的读进程进入。")])])}],!1,null,null,null);e.options.__file="sync.md";_.default=e.exports}}]);