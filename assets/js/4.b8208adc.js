(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{172:function(t,e,i){t.exports=i.p+"assets/img/WX20200412-112609@2x.d06f5943.png"},173:function(t,e,i){t.exports=i.p+"assets/img/WX20200412-171724.16bd6c08.png"},174:function(t,e,i){t.exports=i.p+"assets/img/WX20200412-171845.4180070d.png"},175:function(t,e,i){t.exports=i.p+"assets/img/WX20200412-171935.2c58a048.png"},176:function(t,e,i){t.exports=i.p+"assets/img/WX20200412-173840.6831c10b.png"},177:function(t,e,i){t.exports=i.p+"assets/img/WX20200412-175924.b71a8930.png"},471:function(t,e,i){"use strict";i.r(e);var r=[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"操作系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作系统","aria-hidden":"true"}},[this._v("#")]),this._v(" 操作系统")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"操作系统运行环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作系统运行环境","aria-hidden":"true"}},[this._v("#")]),this._v(" 操作系统运行环境")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"处理器状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#处理器状态","aria-hidden":"true"}},[this._v("#")]),this._v(" 处理器状态")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("程序计数器（PC：program counter）， 记录即将要去除的指令的地址")]),this._v(" "),e("li",[this._v("指令寄存器（IR：instruction register），记录最近取出的指令")]),this._v(" "),e("li",[this._v("程序状态字（PSW：program status word），记录处理器的运行状态如条件码、模式、控制位等信息")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("处理器具有特权级别，能在不同的特权级运行的不同指令集合")]),this._v(" "),e("li",[this._v("硬件机制可将OS与用户程序隔离")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"操作系统需要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作系统需要","aria-hidden":"true"}},[this._v("#")]),this._v(" 操作系统需要")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ul",[i("li",[i("p",[t._v("内核态（Kernel Mode）：运行操作系统程序")])]),t._v(" "),i("li",[i("p",[t._v("用户态（User Mode）：运行用户程序")])]),t._v(" "),i("li",[i("p",[i("strong",[t._v("特权指令")]),t._v(" 只能由操作系统使用，用户程序不能使用的指令")])]),t._v(" "),i("li",[i("p",[i("strong",[t._v("非特权指令")]),t._v(" 用户程序可以使用的指令")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"cpu状态之间的转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cpu状态之间的转换","aria-hidden":"true"}},[this._v("#")]),this._v(" CPU状态之间的转换")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ul",[i("li",[i("p",[t._v("用户态 -> 内核态")]),t._v(" "),i("p",[t._v("唯一途径： "),i("strong",[t._v("中断/异常/陷入机制")])])]),t._v(" "),i("li",[i("p",[t._v("内核态 -> 用户态")]),t._v(" "),i("p",[t._v("设置程序状态字PSW")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"中断与异常机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中断与异常机制","aria-hidden":"true"}},[this._v("#")]),this._v(" 中断与异常机制")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"中断-异常的概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中断-异常的概念","aria-hidden":"true"}},[this._v("#")]),this._v(" 中断/异常的概念")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("CPU对系统发生的某个事件作出的一种反应")]),this._v(" "),e("li",[this._v("CPU暂停正在执行的程序，把刘现场后自动转去执行相应事件的处理程序，处理完成后返回断点，继续执行被打断的程序")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("是随机发生的")]),this._v(" "),e("li",[this._v("是自动处理的")]),this._v(" "),e("li",[this._v("是可以恢复的")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("中断")]),this._v("： 为了支持CPU和设备之间的并行操作。当设备完成I/O后，通过向CPU发送中断报告，让CPU界定如何处理后续的事情。包括：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("pre",[e("code",[this._v("\t- I/O中断\n\t- 时钟中断（如CPU时间片到了）\n\t- 硬件故障\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("异常")]),this._v("： 表示CPU执行指令时本身出现的问题，如算数溢出，访问内存地址时越界或者执行了陷入指令等。这时硬件改变了CPU当前的执行流程，转到相应的错误处理程序或异常处理程序或系统调用。包括：")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ul",[i("li",[t._v("系统调用")]),t._v(" "),i("li",[t._v("页故障/页错误")]),t._v(" "),i("li",[t._v("保护性异常")]),t._v(" "),i("li",[t._v("断点指令")]),t._v(" "),i("li",[t._v("其他程序性异常")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"中断与异常的工作原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中断与异常的工作原理","aria-hidden":"true"}},[this._v("#")]),this._v(" 中断与异常的工作原理")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ul",[i("li",[t._v("硬件该做什么事？ --- 中断/异常"),i("strong",[t._v("响应")]),t._v(" "),i("ul",[i("li",[t._v("捕获中断源发出的中断/异常请求，以一定的方式响应，将处理器控制权交给特定的处理程序")])])]),t._v(" "),i("li",[t._v("软件要做什么事？ --- 中断/异常"),i("strong",[t._v("处理")]),t._v("程序\n"),i("ul",[i("li",[t._v("识别中断/异常类型并完成相应的处理")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"中断与异常的工作原理-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中断与异常的工作原理-2","aria-hidden":"true"}},[this._v("#")]),this._v(" 中断与异常的工作原理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("中断响应过程示意 "),e("img",{attrs:{src:"images/WX20200412-111457@2x.png",alt:"中断响应过程示意"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("CPU在每条执行周期的最后"),e("strong",[this._v("扫描中断寄存器")]),this._v("，查看是否有中断信号。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:i(172),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"系统调用机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#系统调用机制","aria-hidden":"true"}},[this._v("#")]),this._v(" 系统调用机制")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"进程线程模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程线程模型","aria-hidden":"true"}},[this._v("#")]),this._v(" 进程线程模型")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"进程的定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程的定义","aria-hidden":"true"}},[this._v("#")]),this._v(" 进程的定义")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("进程是具有独立功能的程序，关于某个数据集合上的一次运行活动，是系统进行"),e("strong",[this._v("资源分配")]),this._v("和"),e("strong",[this._v("调度")]),this._v("的独立单位。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("程序的一次执行过程")]),this._v(" "),e("li",[this._v("是正在运行程序的抽象")]),this._v(" "),e("li",[this._v("系统资源以进程为单位分配，如内存，文件等，每个进程具有独立的地址空间")]),this._v(" "),e("li",[this._v("操作系统将CPU调度给需要的进程")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"进程控制块pcb（process-control-block）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程控制块pcb（process-control-block）","aria-hidden":"true"}},[this._v("#")]),this._v(" 进程控制块PCB（Process Control Block）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("操作系统用于管理控制进程的一个专门数据结构")]),this._v(" "),e("li",[this._v("记录进程的各种属性，描述进程的动态变化过程")]),this._v(" "),e("li",[this._v("进程表： 所有进程的PCB集合")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("进程描述信息，如进程ID，用户标示符，进程组关系")]),this._v(" "),e("li",[this._v("进程控制信息，如果优先级，代码入口地址")]),this._v(" "),e("li",[this._v("所拥有的资源和使用情况，如虚拟地址空间的状况，打开文件列表")]),this._v(" "),e("li",[this._v("CPU现场信息，寄存器值（PC，PSW，栈指针等）")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"进程状态和状态转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程状态和状态转换","aria-hidden":"true"}},[this._v("#")]),this._v(" 进程状态和状态转换")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("运行态（Running）： 占有CPU，并在CPU上运行")]),this._v(" "),e("li",[this._v("就绪态（Ready）：已经具备运行的条件，但是由于没有空闲CPU而暂时不能运行")]),this._v(" "),e("li",[this._v("等待态（Waiting/Blocked）：又称为阻塞态，因等待某一事件而暂时不能运行")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:i(173),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:i(174),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:i(175),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"进程控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程控制","aria-hidden":"true"}},[this._v("#")]),this._v(" 进程控制")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ul",[i("li",[i("p",[t._v("进程的创建")])]),t._v(" "),i("li",[i("p",[t._v("给新进程分配一个唯一标示以及进程控制块")])]),t._v(" "),i("li",[i("p",[t._v("为进程分配地址空间")])]),t._v(" "),i("li",[i("p",[t._v("初始化进程控制块，设置默认值")])]),t._v(" "),i("li",[i("p",[t._v("设置相应的队列指针")])]),t._v(" "),i("li",[i("p",[t._v("结束进程")]),t._v(" "),i("ul",[i("li",[t._v("收回进程所占有的资源")]),t._v(" "),i("li",[t._v("撤销该进程的PCB")])])]),t._v(" "),i("li",[i("p",[t._v("进程阻塞")]),t._v(" "),i("ul",[i("li",[t._v("处于运行状态的进程，在其运行过程中 期待某一事件发生，如等待键盘输入、等待 磁盘数据传输完成、等待其它进程发送消息， 当被等待的事件未发生时，"),i("strong",[t._v("由进程自己执行 阻塞原语，使自己由运行态变为阻塞态")])])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"unix的fork-实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unix的fork-实现","aria-hidden":"true"}},[this._v("#")]),this._v(" Unix的fork()实现")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ul",[i("li",[i("p",[t._v("为子进程分配一个空闲的进程描述符 proc 结构")])]),t._v(" "),i("li",[i("p",[t._v("分配给子进程唯一标识pid")])]),t._v(" "),i("li",[i("p",[t._v("以一次一页的方式复制父进程地址空间")])]),t._v(" "),i("li",[i("p",[t._v("从父进程处继承共享资源，如打开的文件和当前工")]),t._v(" "),i("p",[t._v("作目录等")])]),t._v(" "),i("li",[i("p",[t._v("将子进程的状态设为就绪，插入到就绪队列")])]),t._v(" "),i("li",[i("p",[t._v("对子进程返回标识符0")])]),t._v(" "),i("li",[i("p",[t._v("向父进程返回子进程的pid")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("进程地址空间")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:i(176),alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"上下文切换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#上下文切换","aria-hidden":"true"}},[this._v("#")]),this._v(" 上下文切换")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("进程运行时，其硬件状态保存在CPU上的寄存器中。寄存器：程序计数器，程序状态字寄存器，栈指针，通用寄存器和其他控制寄存器的值")]),this._v(" "),e("li",[this._v("进程不运行时，这些寄存器的值保存在进程控制块PCB中")]),this._v(" "),e("li",[this._v("当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程","aria-hidden":"true"}},[this._v("#")]),this._v(" 线程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:i(177),alt:""}})])}],_=i(0),s=Object(_.a)({},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("div",{staticClass:"content"},[t._m(0),t._v(" "),i("blockquote",[i("p",[t._v("课件：")]),t._v(" "),i("ol",[i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/01.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("操作系统概述"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/02.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("操作系统运行环境"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/03.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("进程线程模型"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/04.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("处理器调度"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/05.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("同步机制(1)"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/06.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("同步机制(2)"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/07.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("存储模型(1)"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/08.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("存储模型(2)"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/09.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("文件系统(1)"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/10.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("文件系统(2)"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/11.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("I/O系统"),i("OutboundLink")],1)]),t._v(" "),i("li",[i("a",{attrs:{href:"https://github.com/bingbig/bingbig.github.io/raw/dev/OS/pdf/12.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("死锁"),i("OutboundLink")],1)])])]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),i("p",[t._v("常见的控制和状态寄存器：")]),t._v(" "),t._m(3),t._v(" "),i("p",[t._v("需要硬件提供基本运行机制：")]),t._v(" "),t._m(4),t._v(" "),i("p",[t._v("现代处理器通常将CPU状态设计划分为多种状态， 在PSW中专门设置以为，根据运行程序对资源和指令的使用权限而设置不同的CPU状态。")]),t._v(" "),t._m(5),t._v(" "),i("p",[t._v("两种CPU状态：")]),t._v(" "),t._m(6),t._v(" "),i("p",[t._v("x86支持4个处理器特权级别：R0，R1，R2和R3， R0相当于内核态，R3相当于用户态，R1和R2介于两者之间，不同级别能够运行的指令集合不同。")]),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),i("p",[t._v("特点：")]),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),i("p",[t._v("中断响应过程示意")]),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),i("p",[t._v("系统调用是操作系统提供给编程人员的唯一接口，使得CPU状态从用户态陷入内核态。")]),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),i("p",[t._v("进程控制块包含的信息：")]),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),i("p",[t._v("三种基本状态：")]),t._v(" "),t._m(32),t._v(" "),i("p",[t._v("三状态模型和状态转换")]),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),i("p",[t._v("操作系统为每一类进程建立一个或多个队列,队列元素为PCB，伴随进程状态的改变，其PCB从一个队列进入另一个队列。")]),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),i("p",[t._v("Linux采用了写时复制技术COW(Copy-On-Write)加快创建进程。")]),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),t._m(42),t._v(" "),i("p",[t._v("将CPU硬件从一个进程切换到另一个进程的过程称为上下文切换。")]),t._v(" "),t._m(43),t._v(" "),t._m(44),t._v(" "),t._m(45),t._v(" "),i("p",[t._v("http://www.chinesemooc.org/live/685646")])])},r,!1,null,null,null);s.options.__file="os_note.md";e.default=s.exports}}]);